{"version":3,"sources":["../src/index.tsx"],"names":[],"mappings":"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","file":"index.js","sourcesContent":["/**\r\n * ComputeKit React Bindings\r\n * React hooks and utilities for ComputeKit\r\n */\r\n\r\nimport React, {\r\n  useState,\r\n  useEffect,\r\n  useCallback,\r\n  useRef,\r\n  useMemo,\r\n  createContext,\r\n  useContext,\r\n  type ReactNode,\r\n} from 'react';\r\n\r\nimport {\r\n  ComputeKit,\r\n  type ComputeKitOptions,\r\n  type ComputeOptions,\r\n  type ComputeProgress,\r\n  type PoolStats,\r\n  type ComputeFunctionRegistry,\r\n  type RegisteredFunctionName,\r\n  type FunctionInput,\r\n  type FunctionOutput,\r\n  type ComputeFn,\r\n} from '@computekit/core';\r\n\r\n// ============================================================================\r\n// Pipeline Types (defined here for React, also exported from @computekit/core)\r\n// ============================================================================\r\n\r\n/** Status of a pipeline stage */\r\nexport type StageStatus = 'pending' | 'running' | 'completed' | 'failed' | 'skipped';\r\n\r\n/** Detailed information about a single pipeline stage */\r\nexport interface StageInfo<TInput = unknown, TOutput = unknown> {\r\n  /** Unique identifier for the stage */\r\n  id: string;\r\n  /** Display name for the stage */\r\n  name: string;\r\n  /** Name of the registered compute function to execute */\r\n  functionName: string;\r\n  /** Current status of this stage */\r\n  status: StageStatus;\r\n  /** Input data for this stage (set when stage starts) */\r\n  input?: TInput;\r\n  /** Output data from this stage (set when stage completes) */\r\n  output?: TOutput;\r\n  /** Error if stage failed */\r\n  error?: Error;\r\n  /** Start timestamp (ms since epoch) */\r\n  startedAt?: number;\r\n  /** End timestamp (ms since epoch) */\r\n  completedAt?: number;\r\n  /** Duration in milliseconds */\r\n  duration?: number;\r\n  /** Progress within this stage (0-100) */\r\n  progress?: number;\r\n  /** Number of retry attempts */\r\n  retryCount: number;\r\n  /** Compute options specific to this stage */\r\n  options?: ComputeOptions;\r\n}\r\n\r\n/** Configuration for a pipeline stage */\r\nexport interface StageConfig<TInput = unknown, TOutput = unknown> {\r\n  /** Unique identifier for the stage */\r\n  id: string;\r\n  /** Display name for the stage */\r\n  name: string;\r\n  /** Name of the registered compute function */\r\n  functionName: string;\r\n  /** Transform input before passing to compute function */\r\n  transformInput?: (input: TInput, previousResults: unknown[]) => unknown;\r\n  /** Transform output after compute function returns */\r\n  transformOutput?: (output: unknown) => TOutput;\r\n  /** Whether to skip this stage based on previous results */\r\n  shouldSkip?: (input: TInput, previousResults: unknown[]) => boolean;\r\n  /** Maximum retry attempts on failure (default: 0) */\r\n  maxRetries?: number;\r\n  /** Delay between retries in ms (default: 1000) */\r\n  retryDelay?: number;\r\n  /** Compute options for this stage */\r\n  options?: ComputeOptions;\r\n}\r\n\r\n/** Overall pipeline status */\r\nexport type PipelineStatus =\r\n  | 'idle' // Not started\r\n  | 'running' // Currently executing\r\n  | 'paused' // Paused mid-execution\r\n  | 'completed' // All stages completed successfully\r\n  | 'failed' // A stage failed (and wasn't recovered)\r\n  | 'cancelled'; // User cancelled\r\n\r\n/** Metrics for pipeline debugging and reporting */\r\nexport interface PipelineMetrics {\r\n  /** Total stages in pipeline */\r\n  totalStages: number;\r\n  /** Number of completed stages */\r\n  completedStages: number;\r\n  /** Number of failed stages */\r\n  failedStages: number;\r\n  /** Number of skipped stages */\r\n  skippedStages: number;\r\n  /** Total retry attempts across all stages */\r\n  totalRetries: number;\r\n  /** Slowest stage info */\r\n  slowestStage: { id: string; name: string; duration: number } | null;\r\n  /** Fastest stage info */\r\n  fastestStage: { id: string; name: string; duration: number } | null;\r\n  /** Average stage duration */\r\n  averageStageDuration: number;\r\n  /** Timestamp of each stage transition for timeline view */\r\n  timeline: Array<{\r\n    stageId: string;\r\n    stageName: string;\r\n    event: 'started' | 'completed' | 'failed' | 'skipped' | 'retry';\r\n    timestamp: number;\r\n    duration?: number;\r\n    error?: string;\r\n  }>;\r\n}\r\n\r\n/** Comprehensive pipeline state for debugging */\r\nexport interface PipelineState<TInput = unknown, TOutput = unknown> {\r\n  /** Overall pipeline status */\r\n  status: PipelineStatus;\r\n  /** All stage information */\r\n  stages: StageInfo[];\r\n  /** Index of currently executing stage (-1 if not running) */\r\n  currentStageIndex: number;\r\n  /** Current stage info (convenience) */\r\n  currentStage: StageInfo | null;\r\n  /** Overall progress percentage (0-100) */\r\n  progress: number;\r\n  /** Final output from the last stage */\r\n  output: TOutput | null;\r\n  /** Initial input that started the pipeline */\r\n  input: TInput | null;\r\n  /** Error that caused pipeline failure */\r\n  error: Error | null;\r\n  /** Pipeline start timestamp */\r\n  startedAt: number | null;\r\n  /** Pipeline completion timestamp */\r\n  completedAt: number | null;\r\n  /** Total duration in milliseconds */\r\n  totalDuration: number | null;\r\n  /** Results from each completed stage */\r\n  stageResults: unknown[];\r\n  /** Execution metrics for debugging */\r\n  metrics: PipelineMetrics;\r\n}\r\n\r\n/** Result of a single item in parallel batch */\r\nexport interface BatchItemResult<TOutput = unknown> {\r\n  /** Index of the item in original array */\r\n  index: number;\r\n  /** Whether this item succeeded */\r\n  success: boolean;\r\n  /** Result if successful */\r\n  data?: TOutput;\r\n  /** Error if failed */\r\n  error?: Error;\r\n  /** Duration in ms */\r\n  duration: number;\r\n}\r\n\r\n/** Aggregate result of parallel batch processing */\r\nexport interface ParallelBatchResult<TOutput = unknown> {\r\n  /** All individual results */\r\n  results: BatchItemResult<TOutput>[];\r\n  /** Successfully processed items */\r\n  successful: TOutput[];\r\n  /** Failed items with their errors */\r\n  failed: Array<{ index: number; error: Error }>;\r\n  /** Total duration */\r\n  totalDuration: number;\r\n  /** Success rate (0-1) */\r\n  successRate: number;\r\n}\r\n\r\n// ============================================================================\r\n// Context\r\n// ============================================================================\r\n\r\nconst ComputeKitContext = createContext<ComputeKit | null>(null);\r\n\r\n/**\r\n * Props for ComputeKitProvider\r\n */\r\nexport interface ComputeKitProviderProps {\r\n  /** ComputeKit options */\r\n  options?: ComputeKitOptions;\r\n  /** Custom ComputeKit instance */\r\n  instance?: ComputeKit;\r\n  /** Children */\r\n  children: ReactNode;\r\n}\r\n\r\n/**\r\n * Provider component for ComputeKit\r\n *\r\n * @example\r\n * ```tsx\r\n * import { ComputeKitProvider } from '@computekit/react';\r\n *\r\n * function App() {\r\n *   return (\r\n *     <ComputeKitProvider options={{ maxWorkers: 4 }}>\r\n *       <MyApp />\r\n *     </ComputeKitProvider>\r\n *   );\r\n * }\r\n * ```\r\n */\r\nexport function ComputeKitProvider({\r\n  options,\r\n  instance,\r\n  children,\r\n}: ComputeKitProviderProps): React.ReactElement {\r\n  const kit = useMemo(() => {\r\n    return instance ?? new ComputeKit(options);\r\n  }, [instance, options]);\r\n\r\n  useEffect(() => {\r\n    return () => {\r\n      // Only terminate if we created the instance\r\n      if (!instance) {\r\n        kit.terminate();\r\n      }\r\n    };\r\n  }, [kit, instance]);\r\n\r\n  return <ComputeKitContext.Provider value={kit}>{children}</ComputeKitContext.Provider>;\r\n}\r\n\r\n/**\r\n * Get the ComputeKit instance from context\r\n */\r\nexport function useComputeKit(): ComputeKit {\r\n  const kit = useContext(ComputeKitContext);\r\n  if (!kit) {\r\n    throw new Error('useComputeKit must be used within a ComputeKitProvider');\r\n  }\r\n  return kit;\r\n}\r\n\r\n// ============================================================================\r\n// useCompute Hook\r\n// ============================================================================\r\n\r\n/**\r\n * Status of a compute operation\r\n */\r\nexport type ComputeStatus = 'idle' | 'running' | 'success' | 'error' | 'cancelled';\r\n\r\n/**\r\n * State returned by useCompute\r\n */\r\nexport interface UseComputeState<T> {\r\n  /** The computed result */\r\n  data: T | null;\r\n  /** Loading state */\r\n  loading: boolean;\r\n  /** Error if computation failed */\r\n  error: Error | null;\r\n  /** Progress information */\r\n  progress: ComputeProgress | null;\r\n  /** Current status of the computation */\r\n  status: ComputeStatus;\r\n}\r\n\r\n/**\r\n * Actions returned by useCompute\r\n */\r\nexport interface UseComputeActions<TInput> {\r\n  /** Execute the compute function */\r\n  run: (input: TInput, options?: ComputeOptions) => Promise<void>;\r\n  /** Reset the state */\r\n  reset: () => void;\r\n  /** Cancel ongoing computation */\r\n  cancel: () => void;\r\n}\r\n\r\n/**\r\n * Return type for useCompute\r\n */\r\nexport type UseComputeReturn<TInput, TOutput> = UseComputeState<TOutput> &\r\n  UseComputeActions<TInput>;\r\n\r\n/**\r\n * Options for useCompute hook\r\n */\r\nexport interface UseComputeOptions extends ComputeOptions {\r\n  /** Automatically run on mount with initial input */\r\n  autoRun?: boolean;\r\n  /** Initial input for autoRun */\r\n  initialInput?: unknown;\r\n  /** Reset state on new run */\r\n  resetOnRun?: boolean;\r\n}\r\n\r\n/**\r\n * Hook for running compute functions\r\n *\r\n * @example\r\n * ```tsx\r\n * // Basic usage with explicit types\r\n * function FibonacciCalculator() {\r\n *   const { data, loading, error, run } = useCompute<number, number>('fibonacci');\r\n *\r\n *   return (\r\n *     <div>\r\n *       <button onClick={() => run(50)} disabled={loading}>\r\n *         Calculate Fibonacci(50)\r\n *       </button>\r\n *       {loading && <p>Computing...</p>}\r\n *       {error && <p>Error: {error.message}</p>}\r\n *       {data !== null && <p>Result: {data}</p>}\r\n *     </div>\r\n *   );\r\n * }\r\n *\r\n * // With typed registry (extend ComputeFunctionRegistry for autocomplete)\r\n * // declare module '@computekit/core' {\r\n * //   interface ComputeFunctionRegistry {\r\n * //     fibonacci: { input: number; output: number };\r\n * //   }\r\n * // }\r\n * // const { data, run } = useCompute('fibonacci'); // Types are inferred!\r\n * ```\r\n */\r\nexport function useCompute<\r\n  TName extends RegisteredFunctionName,\r\n  TInput = FunctionInput<TName extends string ? TName : never>,\r\n  TOutput = FunctionOutput<TName extends string ? TName : never>,\r\n>(\r\n  functionName: TName,\r\n  options: UseComputeOptions = {}\r\n): UseComputeReturn<\r\n  TName extends keyof ComputeFunctionRegistry\r\n    ? ComputeFunctionRegistry[TName]['input']\r\n    : TInput,\r\n  TName extends keyof ComputeFunctionRegistry\r\n    ? ComputeFunctionRegistry[TName]['output']\r\n    : TOutput\r\n> {\r\n  type ActualInput = TName extends keyof ComputeFunctionRegistry\r\n    ? ComputeFunctionRegistry[TName]['input']\r\n    : TInput;\r\n  type ActualOutput = TName extends keyof ComputeFunctionRegistry\r\n    ? ComputeFunctionRegistry[TName]['output']\r\n    : TOutput;\r\n\r\n  const kit = useComputeKit();\r\n  const abortControllerRef = useRef<AbortController | null>(null);\r\n  const cancelledRef = useRef(false);\r\n\r\n  const [state, setState] = useState<UseComputeState<ActualOutput>>({\r\n    data: null,\r\n    loading: false,\r\n    error: null,\r\n    progress: null,\r\n    status: 'idle',\r\n  });\r\n\r\n  const reset = useCallback(() => {\r\n    cancelledRef.current = false;\r\n    setState({\r\n      data: null,\r\n      loading: false,\r\n      error: null,\r\n      progress: null,\r\n      status: 'idle',\r\n    });\r\n  }, []);\r\n\r\n  const cancel = useCallback(() => {\r\n    if (abortControllerRef.current) {\r\n      cancelledRef.current = true;\r\n      abortControllerRef.current.abort();\r\n      abortControllerRef.current = null;\r\n      setState((prev) => ({\r\n        ...prev,\r\n        loading: false,\r\n        status: 'cancelled',\r\n      }));\r\n    }\r\n  }, []);\r\n\r\n  const run = useCallback(\r\n    async (input: ActualInput, runOptions?: ComputeOptions) => {\r\n      // Cancel any ongoing computation\r\n      cancel();\r\n      cancelledRef.current = false;\r\n\r\n      // Create new abort controller\r\n      const abortController = new AbortController();\r\n      abortControllerRef.current = abortController;\r\n\r\n      // Reset state if configured\r\n      if (options.resetOnRun !== false) {\r\n        setState((prev) => ({\r\n          ...prev,\r\n          loading: true,\r\n          error: null,\r\n          progress: null,\r\n          status: 'running',\r\n        }));\r\n      } else {\r\n        setState((prev) => ({ ...prev, loading: true, status: 'running' }));\r\n      }\r\n\r\n      try {\r\n        const result = (await kit.run(functionName, input, {\r\n          ...options,\r\n          ...runOptions,\r\n          signal: runOptions?.signal ?? abortController.signal,\r\n          onProgress: (progress) => {\r\n            setState((prev) => ({ ...prev, progress }));\r\n            options.onProgress?.(progress);\r\n            runOptions?.onProgress?.(progress);\r\n          },\r\n        })) as ActualOutput;\r\n\r\n        if (!abortController.signal.aborted) {\r\n          setState({\r\n            data: result,\r\n            loading: false,\r\n            error: null,\r\n            progress: null,\r\n            status: 'success',\r\n          });\r\n        }\r\n      } catch (err) {\r\n        if (!abortController.signal.aborted && !cancelledRef.current) {\r\n          setState({\r\n            data: null,\r\n            loading: false,\r\n            error: err instanceof Error ? err : new Error(String(err)),\r\n            progress: null,\r\n            status: 'error',\r\n          });\r\n        }\r\n      }\r\n    },\r\n    [kit, functionName, options, cancel]\r\n  );\r\n\r\n  // Auto-run on mount if configured\r\n  useEffect(() => {\r\n    if (options.autoRun && options.initialInput !== undefined) {\r\n      run(options.initialInput as ActualInput);\r\n    }\r\n    // Only run on mount\r\n    // eslint-disable-next-line react-hooks/exhaustive-deps\r\n  }, []);\r\n\r\n  // Cleanup on unmount\r\n  useEffect(() => {\r\n    return () => {\r\n      cancel();\r\n    };\r\n  }, [cancel]);\r\n\r\n  return {\r\n    ...state,\r\n    run,\r\n    reset,\r\n    cancel,\r\n  } as UseComputeReturn<ActualInput, ActualOutput>;\r\n}\r\n\r\n// ============================================================================\r\n// useComputeCallback Hook\r\n// ============================================================================\r\n\r\n/**\r\n * Hook that returns a memoized async function for compute operations\r\n *\r\n * @example\r\n * ```tsx\r\n * // Basic usage with explicit types\r\n * function Calculator() {\r\n *   const calculate = useComputeCallback<number[], number>('sum');\r\n *\r\n *   const handleClick = async () => {\r\n *     const result = await calculate([1, 2, 3, 4, 5]);\r\n *     console.log(result);\r\n *   };\r\n *\r\n *   return <button onClick={handleClick}>Calculate Sum</button>;\r\n * }\r\n *\r\n * // With typed registry - types are inferred!\r\n * // const calculate = useComputeCallback('sum');\r\n * ```\r\n */\r\nexport function useComputeCallback<\r\n  TName extends RegisteredFunctionName,\r\n  TInput = FunctionInput<TName extends string ? TName : never>,\r\n  TOutput = FunctionOutput<TName extends string ? TName : never>,\r\n>(\r\n  functionName: TName,\r\n  options?: ComputeOptions\r\n): (\r\n  input: TName extends keyof ComputeFunctionRegistry\r\n    ? ComputeFunctionRegistry[TName]['input']\r\n    : TInput,\r\n  runOptions?: ComputeOptions\r\n) => Promise<\r\n  TName extends keyof ComputeFunctionRegistry\r\n    ? ComputeFunctionRegistry[TName]['output']\r\n    : TOutput\r\n> {\r\n  type ActualInput = TName extends keyof ComputeFunctionRegistry\r\n    ? ComputeFunctionRegistry[TName]['input']\r\n    : TInput;\r\n  type ActualOutput = TName extends keyof ComputeFunctionRegistry\r\n    ? ComputeFunctionRegistry[TName]['output']\r\n    : TOutput;\r\n\r\n  const kit = useComputeKit();\r\n\r\n  return useCallback(\r\n    (input: ActualInput, runOptions?: ComputeOptions): Promise<ActualOutput> => {\r\n      return kit.run(functionName, input, {\r\n        ...options,\r\n        ...runOptions,\r\n      }) as Promise<ActualOutput>;\r\n    },\r\n    [kit, functionName, options]\r\n  );\r\n}\r\n\r\n// ============================================================================\r\n// useComputeFunction Hook\r\n// ============================================================================\r\n\r\n/**\r\n * Hook to register and use a compute function\r\n *\r\n * @example\r\n * ```tsx\r\n * // Basic usage\r\n * function MyComponent() {\r\n *   const { run, loading, data } = useComputeFunction(\r\n *     'myFunction',\r\n *     (input: number) => input * 2\r\n *   );\r\n *\r\n *   return (\r\n *     <button onClick={() => run(5)} disabled={loading}>\r\n *       {loading ? 'Computing...' : `Result: ${data}`}\r\n *     </button>\r\n *   );\r\n * }\r\n *\r\n * // With typed registry - provides autocomplete and type safety\r\n * // declare module '@computekit/core' {\r\n * //   interface ComputeFunctionRegistry {\r\n * //     myFunction: { input: number; output: number };\r\n * //   }\r\n * // }\r\n * ```\r\n */\r\nexport function useComputeFunction<\r\n  TName extends RegisteredFunctionName,\r\n  TInput = FunctionInput<TName extends string ? TName : never>,\r\n  TOutput = FunctionOutput<TName extends string ? TName : never>,\r\n>(\r\n  name: TName,\r\n  fn: TName extends keyof ComputeFunctionRegistry\r\n    ? ComputeFn<\r\n        ComputeFunctionRegistry[TName]['input'],\r\n        ComputeFunctionRegistry[TName]['output']\r\n      >\r\n    : ComputeFn<TInput, TOutput>,\r\n  options?: UseComputeOptions\r\n): UseComputeReturn<\r\n  TName extends keyof ComputeFunctionRegistry\r\n    ? ComputeFunctionRegistry[TName]['input']\r\n    : TInput,\r\n  TName extends keyof ComputeFunctionRegistry\r\n    ? ComputeFunctionRegistry[TName]['output']\r\n    : TOutput\r\n> {\r\n  const kit = useComputeKit();\r\n\r\n  // Register function on mount\r\n  useEffect(() => {\r\n    kit.register(name, fn);\r\n  }, [kit, name, fn]);\r\n\r\n  return useCompute(name, options);\r\n}\r\n\r\n// ============================================================================\r\n// usePoolStats Hook\r\n// ============================================================================\r\n\r\n/**\r\n * Hook to get worker pool statistics\r\n *\r\n * @example\r\n * ```tsx\r\n * function PoolMonitor() {\r\n *   const stats = usePoolStats(1000); // Update every second\r\n *\r\n *   return (\r\n *     <div>\r\n *       <p>Active Workers: {stats.activeWorkers}</p>\r\n *       <p>Queue Length: {stats.queueLength}</p>\r\n *       <p>Tasks Completed: {stats.tasksCompleted}</p>\r\n *     </div>\r\n *   );\r\n * }\r\n * ```\r\n */\r\nexport function usePoolStats(refreshInterval: number = 0): PoolStats {\r\n  const kit = useComputeKit();\r\n  const [stats, setStats] = useState<PoolStats>(() => kit.getStats());\r\n\r\n  useEffect(() => {\r\n    // For one-time fetch (refreshInterval <= 0), we rely on the initial state\r\n    if (refreshInterval <= 0) {\r\n      return;\r\n    }\r\n\r\n    const interval = setInterval(() => {\r\n      setStats(kit.getStats());\r\n    }, refreshInterval);\r\n\r\n    return () => clearInterval(interval);\r\n  }, [kit, refreshInterval]);\r\n\r\n  return stats;\r\n}\r\n\r\n// ============================================================================\r\n// useWasmSupport Hook\r\n// ============================================================================\r\n\r\n/**\r\n * Hook to check WASM support\r\n */\r\nexport function useWasmSupport(): boolean {\r\n  const kit = useComputeKit();\r\n  return kit.isWasmSupported();\r\n}\r\n\r\n// ============================================================================\r\n// usePipeline Hook - Multi-stage Processing\r\n// ============================================================================\r\n\r\n/**\r\n * Options for usePipeline hook\r\n */\r\nexport interface UsePipelineOptions {\r\n  /** Stop pipeline on first stage failure (default: true) */\r\n  stopOnError?: boolean;\r\n  /** Global timeout for entire pipeline in ms */\r\n  timeout?: number;\r\n  /** Enable detailed timeline tracking (default: true) */\r\n  trackTimeline?: boolean;\r\n  /** Called when pipeline state changes */\r\n  onStateChange?: (state: PipelineState) => void;\r\n  /** Called when a stage starts */\r\n  onStageStart?: (stage: StageInfo) => void;\r\n  /** Called when a stage completes */\r\n  onStageComplete?: (stage: StageInfo) => void;\r\n  /** Called when a stage fails */\r\n  onStageError?: (stage: StageInfo, error: Error) => void;\r\n  /** Called when a stage is retried */\r\n  onStageRetry?: (stage: StageInfo, attempt: number) => void;\r\n  /** Automatically run pipeline on mount */\r\n  autoRun?: boolean;\r\n  /** Initial input for autoRun */\r\n  initialInput?: unknown;\r\n}\r\n\r\n/**\r\n * Actions returned by usePipeline\r\n */\r\nexport interface UsePipelineActions<TInput> {\r\n  /** Start the pipeline with input */\r\n  run: (input: TInput) => Promise<void>;\r\n  /** Cancel the running pipeline */\r\n  cancel: () => void;\r\n  /** Reset pipeline to initial state */\r\n  reset: () => void;\r\n  /** Pause the pipeline (if supported) */\r\n  pause: () => void;\r\n  /** Resume a paused pipeline */\r\n  resume: () => void;\r\n  /** Retry failed stages */\r\n  retry: () => Promise<void>;\r\n  /** Get a formatted report of the pipeline execution */\r\n  getReport: () => PipelineReport;\r\n}\r\n\r\n/**\r\n * Formatted report for debugging\r\n */\r\nexport interface PipelineReport {\r\n  /** Human-readable summary */\r\n  summary: string;\r\n  /** Detailed stage-by-stage breakdown */\r\n  stageDetails: Array<{\r\n    name: string;\r\n    status: StageStatus;\r\n    duration: string;\r\n    error?: string;\r\n  }>;\r\n  /** Timeline of events */\r\n  timeline: string[];\r\n  /** Performance insights */\r\n  insights: string[];\r\n  /** Raw metrics */\r\n  metrics: PipelineMetrics;\r\n}\r\n\r\n/**\r\n * Return type for usePipeline\r\n */\r\nexport type UsePipelineReturn<TInput, TOutput> = PipelineState<TInput, TOutput> &\r\n  UsePipelineActions<TInput> & {\r\n    /** Whether pipeline is currently running */\r\n    isRunning: boolean;\r\n    /** Whether pipeline completed successfully */\r\n    isComplete: boolean;\r\n    /** Whether pipeline has failed */\r\n    isFailed: boolean;\r\n    /** Quick access to check if a specific stage is done */\r\n    isStageComplete: (stageId: string) => boolean;\r\n    /** Get a specific stage by ID */\r\n    getStage: (stageId: string) => StageInfo | undefined;\r\n  };\r\n\r\n/**\r\n * Create initial pipeline state\r\n */\r\nfunction createInitialPipelineState<TInput, TOutput>(\r\n  stages: StageConfig[]\r\n): PipelineState<TInput, TOutput> {\r\n  return {\r\n    status: 'idle',\r\n    stages: stages.map((config) => ({\r\n      id: config.id,\r\n      name: config.name,\r\n      functionName: config.functionName,\r\n      status: 'pending' as StageStatus,\r\n      retryCount: 0,\r\n      options: config.options,\r\n    })),\r\n    currentStageIndex: -1,\r\n    currentStage: null,\r\n    progress: 0,\r\n    output: null,\r\n    input: null,\r\n    error: null,\r\n    startedAt: null,\r\n    completedAt: null,\r\n    totalDuration: null,\r\n    stageResults: [],\r\n    metrics: {\r\n      totalStages: stages.length,\r\n      completedStages: 0,\r\n      failedStages: 0,\r\n      skippedStages: 0,\r\n      totalRetries: 0,\r\n      slowestStage: null,\r\n      fastestStage: null,\r\n      averageStageDuration: 0,\r\n      timeline: [],\r\n    },\r\n  };\r\n}\r\n\r\n/**\r\n * Format duration in human-readable format\r\n */\r\nfunction formatDuration(ms: number): string {\r\n  if (ms < 1000) return `${ms.toFixed(0)}ms`;\r\n  if (ms < 60000) return `${(ms / 1000).toFixed(2)}s`;\r\n  return `${(ms / 60000).toFixed(2)}min`;\r\n}\r\n\r\n/**\r\n * Hook for multi-stage pipeline processing\r\n *\r\n * Provides comprehensive debugging, progress tracking, and error handling\r\n * for complex multi-stage compute workflows.\r\n *\r\n * @example\r\n * ```tsx\r\n * function FileProcessor() {\r\n *   const pipeline = usePipeline<string[], ProcessedFiles>([\r\n *     { id: 'download', name: 'Download Files', functionName: 'downloadFiles' },\r\n *     { id: 'process', name: 'Process Files', functionName: 'processFiles' },\r\n *     { id: 'compress', name: 'Compress Output', functionName: 'compressFiles' },\r\n *   ]);\r\n *\r\n *   return (\r\n *     <div>\r\n *       <button onClick={() => pipeline.run(urls)} disabled={pipeline.isRunning}>\r\n *         Start Processing\r\n *       </button>\r\n *\r\n *       <div>Status: {pipeline.status}</div>\r\n *       <div>Progress: {pipeline.progress.toFixed(0)}%</div>\r\n *\r\n *       {pipeline.currentStage && (\r\n *         <div>Current: {pipeline.currentStage.name}</div>\r\n *       )}\r\n *\r\n *       {pipeline.stages.map(stage => (\r\n *         <div key={stage.id}>\r\n *           {stage.name}: {stage.status}\r\n *           {stage.duration && ` (${stage.duration}ms)`}\r\n *         </div>\r\n *       ))}\r\n *\r\n *       {pipeline.isFailed && (\r\n *         <button onClick={pipeline.retry}>Retry Failed</button>\r\n *       )}\r\n *\r\n *       {pipeline.isComplete && (\r\n *         <pre>{JSON.stringify(pipeline.getReport(), null, 2)}</pre>\r\n *       )}\r\n *     </div>\r\n *   );\r\n * }\r\n * ```\r\n */\r\nexport function usePipeline<TInput = unknown, TOutput = unknown>(\r\n  stageConfigs: StageConfig[],\r\n  options: UsePipelineOptions = {}\r\n): UsePipelineReturn<TInput, TOutput> {\r\n  const kit = useComputeKit();\r\n  const abortControllerRef = useRef<AbortController | null>(null);\r\n  const pausedRef = useRef(false);\r\n  const resumePromiseRef = useRef<{\r\n    resolve: () => void;\r\n    reject: (err: Error) => void;\r\n  } | null>(null);\r\n\r\n  const [state, setState] = useState<PipelineState<TInput, TOutput>>(() =>\r\n    createInitialPipelineState<TInput, TOutput>(stageConfigs)\r\n  );\r\n\r\n  // Memoize stage configs to prevent unnecessary re-renders\r\n  const stages = useMemo(() => stageConfigs, [stageConfigs]);\r\n\r\n  /**\r\n   * Add event to timeline\r\n   */\r\n  const addTimelineEvent = useCallback(\r\n    (\r\n      stageId: string,\r\n      stageName: string,\r\n      event: 'started' | 'completed' | 'failed' | 'skipped' | 'retry',\r\n      duration?: number,\r\n      error?: string\r\n    ) => {\r\n      if (options.trackTimeline === false) return;\r\n\r\n      setState((prev) => ({\r\n        ...prev,\r\n        metrics: {\r\n          ...prev.metrics,\r\n          timeline: [\r\n            ...prev.metrics.timeline,\r\n            {\r\n              stageId,\r\n              stageName,\r\n              event,\r\n              timestamp: Date.now(),\r\n              duration,\r\n              error,\r\n            },\r\n          ],\r\n        },\r\n      }));\r\n    },\r\n    [options.trackTimeline]\r\n  );\r\n\r\n  /**\r\n   * Update metrics after stage completion\r\n   */\r\n  const updateMetrics = useCallback(\r\n    (_completedStage: StageInfo, allStages: StageInfo[]) => {\r\n      const completedStages = allStages.filter((s) => s.status === 'completed');\r\n      const durations = completedStages\r\n        .filter((s) => s.duration !== undefined)\r\n        .map((s) => ({ id: s.id, name: s.name, duration: s.duration! }));\r\n\r\n      const slowest = durations.length\r\n        ? durations.reduce((a, b) => (a.duration > b.duration ? a : b))\r\n        : null;\r\n      const fastest = durations.length\r\n        ? durations.reduce((a, b) => (a.duration < b.duration ? a : b))\r\n        : null;\r\n      const avgDuration = durations.length\r\n        ? durations.reduce((sum, d) => sum + d.duration, 0) / durations.length\r\n        : 0;\r\n\r\n      return {\r\n        totalStages: allStages.length,\r\n        completedStages: completedStages.length,\r\n        failedStages: allStages.filter((s) => s.status === 'failed').length,\r\n        skippedStages: allStages.filter((s) => s.status === 'skipped').length,\r\n        totalRetries: allStages.reduce((sum, s) => sum + s.retryCount, 0),\r\n        slowestStage: slowest,\r\n        fastestStage: fastest,\r\n        averageStageDuration: avgDuration,\r\n      };\r\n    },\r\n    []\r\n  );\r\n\r\n  /**\r\n   * Execute a single stage with retries\r\n   */\r\n  const executeStage = useCallback(\r\n    async (\r\n      stageConfig: StageConfig,\r\n      stageIndex: number,\r\n      input: unknown,\r\n      previousResults: unknown[],\r\n      signal: AbortSignal\r\n    ): Promise<{ success: boolean; output?: unknown; error?: Error }> => {\r\n      const maxRetries = stageConfig.maxRetries ?? 0;\r\n      const retryDelay = stageConfig.retryDelay ?? 1000;\r\n      let lastError: Error | undefined;\r\n\r\n      for (let attempt = 0; attempt <= maxRetries; attempt++) {\r\n        // Check for abort\r\n        if (signal.aborted) {\r\n          return { success: false, error: new Error('Pipeline cancelled') };\r\n        }\r\n\r\n        // Check for pause\r\n        if (pausedRef.current) {\r\n          await new Promise<void>((resolve, reject) => {\r\n            resumePromiseRef.current = { resolve, reject };\r\n          });\r\n        }\r\n\r\n        // Check if should skip\r\n        if (stageConfig.shouldSkip?.(input as never, previousResults)) {\r\n          setState((prev) => {\r\n            const newStages = [...prev.stages];\r\n            newStages[stageIndex] = {\r\n              ...newStages[stageIndex],\r\n              status: 'skipped',\r\n            };\r\n            return {\r\n              ...prev,\r\n              stages: newStages,\r\n            };\r\n          });\r\n          addTimelineEvent(stageConfig.id, stageConfig.name, 'skipped');\r\n          options.onStageComplete?.(state.stages[stageIndex]);\r\n          return { success: true, output: previousResults[previousResults.length - 1] };\r\n        }\r\n\r\n        // Transform input if needed\r\n        const transformedInput = stageConfig.transformInput\r\n          ? stageConfig.transformInput(input as never, previousResults)\r\n          : input;\r\n\r\n        const startTime = performance.now();\r\n\r\n        // Update stage to running\r\n        setState((prev) => {\r\n          const newStages = [...prev.stages];\r\n          newStages[stageIndex] = {\r\n            ...newStages[stageIndex],\r\n            status: 'running',\r\n            input: transformedInput,\r\n            startedAt: Date.now(),\r\n            retryCount: attempt,\r\n          };\r\n          return {\r\n            ...prev,\r\n            stages: newStages,\r\n            currentStageIndex: stageIndex,\r\n            currentStage: newStages[stageIndex],\r\n          };\r\n        });\r\n\r\n        if (attempt === 0) {\r\n          addTimelineEvent(stageConfig.id, stageConfig.name, 'started');\r\n          options.onStageStart?.(state.stages[stageIndex]);\r\n        } else {\r\n          addTimelineEvent(stageConfig.id, stageConfig.name, 'retry');\r\n          options.onStageRetry?.(state.stages[stageIndex], attempt);\r\n        }\r\n\r\n        try {\r\n          const result = await kit.run(stageConfig.functionName, transformedInput, {\r\n            ...stageConfig.options,\r\n            signal,\r\n            onProgress: (progress) => {\r\n              setState((prev) => {\r\n                const newStages = [...prev.stages];\r\n                newStages[stageIndex] = {\r\n                  ...newStages[stageIndex],\r\n                  progress: progress.percent,\r\n                };\r\n                // Calculate overall progress\r\n                const stageProgress = progress.percent / 100;\r\n                const overallProgress =\r\n                  ((stageIndex + stageProgress) / stages.length) * 100;\r\n                return {\r\n                  ...prev,\r\n                  stages: newStages,\r\n                  progress: overallProgress,\r\n                };\r\n              });\r\n            },\r\n          });\r\n\r\n          const duration = performance.now() - startTime;\r\n\r\n          // Transform output if needed\r\n          const transformedOutput = stageConfig.transformOutput\r\n            ? stageConfig.transformOutput(result)\r\n            : result;\r\n\r\n          // Update stage to completed\r\n          setState((prev) => {\r\n            const newStages = [...prev.stages];\r\n            newStages[stageIndex] = {\r\n              ...newStages[stageIndex],\r\n              status: 'completed',\r\n              output: transformedOutput,\r\n              completedAt: Date.now(),\r\n              duration,\r\n              progress: 100,\r\n            };\r\n\r\n            const newMetrics = {\r\n              ...prev.metrics,\r\n              ...updateMetrics(newStages[stageIndex], newStages),\r\n            };\r\n\r\n            return {\r\n              ...prev,\r\n              stages: newStages,\r\n              metrics: newMetrics,\r\n              progress: ((stageIndex + 1) / stages.length) * 100,\r\n            };\r\n          });\r\n\r\n          addTimelineEvent(stageConfig.id, stageConfig.name, 'completed', duration);\r\n          options.onStageComplete?.(state.stages[stageIndex]);\r\n\r\n          return { success: true, output: transformedOutput };\r\n        } catch (err) {\r\n          lastError = err instanceof Error ? err : new Error(String(err));\r\n\r\n          if (attempt < maxRetries) {\r\n            // Wait before retry\r\n            await new Promise((resolve) => setTimeout(resolve, retryDelay));\r\n            continue;\r\n          }\r\n\r\n          // Final failure\r\n          const duration = performance.now() - startTime;\r\n\r\n          setState((prev) => {\r\n            const newStages = [...prev.stages];\r\n            newStages[stageIndex] = {\r\n              ...newStages[stageIndex],\r\n              status: 'failed',\r\n              error: lastError,\r\n              completedAt: Date.now(),\r\n              duration,\r\n            };\r\n            return {\r\n              ...prev,\r\n              stages: newStages,\r\n              metrics: {\r\n                ...prev.metrics,\r\n                failedStages: prev.metrics.failedStages + 1,\r\n              },\r\n            };\r\n          });\r\n\r\n          addTimelineEvent(\r\n            stageConfig.id,\r\n            stageConfig.name,\r\n            'failed',\r\n            duration,\r\n            lastError.message\r\n          );\r\n          options.onStageError?.(state.stages[stageIndex], lastError);\r\n\r\n          return { success: false, error: lastError };\r\n        }\r\n      }\r\n\r\n      return { success: false, error: lastError };\r\n    },\r\n    [kit, stages, state.stages, addTimelineEvent, updateMetrics, options]\r\n  );\r\n\r\n  /**\r\n   * Run the pipeline\r\n   */\r\n  const run = useCallback(\r\n    async (input: TInput): Promise<void> => {\r\n      // Cancel any existing run\r\n      if (abortControllerRef.current) {\r\n        abortControllerRef.current.abort();\r\n      }\r\n\r\n      const abortController = new AbortController();\r\n      abortControllerRef.current = abortController;\r\n      pausedRef.current = false;\r\n\r\n      const startTime = Date.now();\r\n\r\n      // Reset state\r\n      setState(() => ({\r\n        ...createInitialPipelineState<TInput, TOutput>(stages),\r\n        status: 'running',\r\n        input,\r\n        startedAt: startTime,\r\n      }));\r\n\r\n      const stageResults: unknown[] = [];\r\n      let currentInput: unknown = input;\r\n      let finalError: Error | null = null;\r\n\r\n      for (let i = 0; i < stages.length; i++) {\r\n        if (abortController.signal.aborted) {\r\n          setState((prev) => ({\r\n            ...prev,\r\n            status: 'cancelled',\r\n            completedAt: Date.now(),\r\n            totalDuration: Date.now() - startTime,\r\n          }));\r\n          return;\r\n        }\r\n\r\n        const result = await executeStage(\r\n          stages[i],\r\n          i,\r\n          currentInput,\r\n          stageResults,\r\n          abortController.signal\r\n        );\r\n\r\n        if (!result.success) {\r\n          finalError = result.error ?? new Error('Stage failed');\r\n\r\n          if (options.stopOnError !== false) {\r\n            setState((prev) => ({\r\n              ...prev,\r\n              status: 'failed',\r\n              error: finalError,\r\n              stageResults,\r\n              completedAt: Date.now(),\r\n              totalDuration: Date.now() - startTime,\r\n            }));\r\n            return;\r\n          }\r\n        }\r\n\r\n        if (result.output !== undefined) {\r\n          stageResults.push(result.output);\r\n          currentInput = result.output;\r\n        }\r\n      }\r\n\r\n      // Pipeline completed\r\n      setState((prev) => ({\r\n        ...prev,\r\n        status: finalError ? 'failed' : 'completed',\r\n        output: (currentInput as TOutput) ?? null,\r\n        error: finalError,\r\n        stageResults,\r\n        completedAt: Date.now(),\r\n        totalDuration: Date.now() - startTime,\r\n        currentStageIndex: -1,\r\n        currentStage: null,\r\n        progress: 100,\r\n      }));\r\n\r\n      options.onStateChange?.(state);\r\n    },\r\n    [stages, executeStage, options, state]\r\n  );\r\n\r\n  /**\r\n   * Cancel the pipeline\r\n   */\r\n  const cancel = useCallback(() => {\r\n    if (abortControllerRef.current) {\r\n      abortControllerRef.current.abort();\r\n      abortControllerRef.current = null;\r\n    }\r\n    if (resumePromiseRef.current) {\r\n      resumePromiseRef.current.reject(new Error('Pipeline cancelled'));\r\n      resumePromiseRef.current = null;\r\n    }\r\n    setState((prev) => ({\r\n      ...prev,\r\n      status: 'cancelled',\r\n      completedAt: Date.now(),\r\n      totalDuration: prev.startedAt ? Date.now() - prev.startedAt : null,\r\n    }));\r\n  }, []);\r\n\r\n  /**\r\n   * Reset the pipeline\r\n   */\r\n  const reset = useCallback(() => {\r\n    cancel();\r\n    setState(createInitialPipelineState<TInput, TOutput>(stages));\r\n  }, [cancel, stages]);\r\n\r\n  /**\r\n   * Pause the pipeline\r\n   */\r\n  const pause = useCallback(() => {\r\n    pausedRef.current = true;\r\n    setState((prev) => ({\r\n      ...prev,\r\n      status: 'paused',\r\n    }));\r\n  }, []);\r\n\r\n  /**\r\n   * Resume the pipeline\r\n   */\r\n  const resume = useCallback(() => {\r\n    pausedRef.current = false;\r\n    if (resumePromiseRef.current) {\r\n      resumePromiseRef.current.resolve();\r\n      resumePromiseRef.current = null;\r\n    }\r\n    setState((prev) => ({\r\n      ...prev,\r\n      status: 'running',\r\n    }));\r\n  }, []);\r\n\r\n  /**\r\n   * Retry failed stages\r\n   */\r\n  const retry = useCallback(async (): Promise<void> => {\r\n    if (state.status !== 'failed' || !state.input) return;\r\n\r\n    // Find first failed stage\r\n    const failedIndex = state.stages.findIndex((s) => s.status === 'failed');\r\n    if (failedIndex === -1) return;\r\n\r\n    // Get input for failed stage (output of previous stage or original input)\r\n    const retryInput =\r\n      failedIndex === 0 ? state.input : state.stageResults[failedIndex - 1];\r\n\r\n    // Create new abort controller\r\n    const abortController = new AbortController();\r\n    abortControllerRef.current = abortController;\r\n\r\n    setState((prev) => ({\r\n      ...prev,\r\n      status: 'running',\r\n      error: null,\r\n    }));\r\n\r\n    const stageResults = [...state.stageResults.slice(0, failedIndex)];\r\n    let currentInput = retryInput;\r\n\r\n    for (let i = failedIndex; i < stages.length; i++) {\r\n      if (abortController.signal.aborted) {\r\n        setState((prev) => ({ ...prev, status: 'cancelled' }));\r\n        return;\r\n      }\r\n\r\n      const result = await executeStage(\r\n        stages[i],\r\n        i,\r\n        currentInput,\r\n        stageResults,\r\n        abortController.signal\r\n      );\r\n\r\n      if (!result.success) {\r\n        setState((prev) => ({\r\n          ...prev,\r\n          status: 'failed',\r\n          error: result.error ?? new Error('Stage failed'),\r\n          stageResults,\r\n        }));\r\n        return;\r\n      }\r\n\r\n      if (result.output !== undefined) {\r\n        stageResults.push(result.output);\r\n        currentInput = result.output;\r\n      }\r\n    }\r\n\r\n    setState((prev) => ({\r\n      ...prev,\r\n      status: 'completed',\r\n      output: currentInput as TOutput,\r\n      stageResults,\r\n      completedAt: Date.now(),\r\n      totalDuration: prev.startedAt ? Date.now() - prev.startedAt : null,\r\n      progress: 100,\r\n    }));\r\n  }, [state, stages, executeStage]);\r\n\r\n  /**\r\n   * Generate execution report\r\n   */\r\n  const getReport = useCallback((): PipelineReport => {\r\n    const stageDetails = state.stages.map((stage) => ({\r\n      name: stage.name,\r\n      status: stage.status,\r\n      duration: stage.duration ? formatDuration(stage.duration) : '-',\r\n      error: stage.error?.message,\r\n    }));\r\n\r\n    const timeline = state.metrics.timeline.map((event) => {\r\n      const time = new Date(event.timestamp).toISOString().split('T')[1].split('.')[0];\r\n      const duration = event.duration ? ` (${formatDuration(event.duration)})` : '';\r\n      const error = event.error ? ` - ${event.error}` : '';\r\n      return `[${time}] ${event.stageName}: ${event.event}${duration}${error}`;\r\n    });\r\n\r\n    const insights: string[] = [];\r\n\r\n    if (state.metrics.slowestStage) {\r\n      insights.push(\r\n        `Slowest stage: ${state.metrics.slowestStage.name} (${formatDuration(\r\n          state.metrics.slowestStage.duration\r\n        )})`\r\n      );\r\n    }\r\n\r\n    if (state.metrics.fastestStage) {\r\n      insights.push(\r\n        `Fastest stage: ${state.metrics.fastestStage.name} (${formatDuration(\r\n          state.metrics.fastestStage.duration\r\n        )})`\r\n      );\r\n    }\r\n\r\n    if (state.metrics.totalRetries > 0) {\r\n      insights.push(`Total retries: ${state.metrics.totalRetries}`);\r\n    }\r\n\r\n    if (state.metrics.averageStageDuration > 0) {\r\n      insights.push(\r\n        `Average stage duration: ${formatDuration(state.metrics.averageStageDuration)}`\r\n      );\r\n    }\r\n\r\n    const successRate =\r\n      state.metrics.totalStages > 0\r\n        ? (state.metrics.completedStages / state.metrics.totalStages) * 100\r\n        : 0;\r\n\r\n    const summary = [\r\n      `Pipeline Status: ${state.status.toUpperCase()}`,\r\n      `Stages: ${state.metrics.completedStages}/${state.metrics.totalStages} completed`,\r\n      `Success Rate: ${successRate.toFixed(0)}%`,\r\n      state.totalDuration ? `Total Duration: ${formatDuration(state.totalDuration)}` : '',\r\n      state.error ? `Error: ${state.error.message}` : '',\r\n    ]\r\n      .filter(Boolean)\r\n      .join('\\n');\r\n\r\n    return {\r\n      summary,\r\n      stageDetails,\r\n      timeline,\r\n      insights,\r\n      metrics: state.metrics,\r\n    };\r\n  }, [state]);\r\n\r\n  /**\r\n   * Check if a stage is complete\r\n   */\r\n  const isStageComplete = useCallback(\r\n    (stageId: string): boolean => {\r\n      const stage = state.stages.find((s) => s.id === stageId);\r\n      return stage?.status === 'completed';\r\n    },\r\n    [state.stages]\r\n  );\r\n\r\n  /**\r\n   * Get a stage by ID\r\n   */\r\n  const getStage = useCallback(\r\n    (stageId: string): StageInfo | undefined => {\r\n      return state.stages.find((s) => s.id === stageId);\r\n    },\r\n    [state.stages]\r\n  );\r\n\r\n  // Auto-run on mount if configured\r\n  useEffect(() => {\r\n    if (options.autoRun && options.initialInput !== undefined) {\r\n      run(options.initialInput as TInput);\r\n    }\r\n    // eslint-disable-next-line react-hooks/exhaustive-deps\r\n  }, []);\r\n\r\n  // Cleanup on unmount\r\n  useEffect(() => {\r\n    return () => {\r\n      cancel();\r\n    };\r\n  }, [cancel]);\r\n\r\n  return {\r\n    ...state,\r\n    run,\r\n    cancel,\r\n    reset,\r\n    pause,\r\n    resume,\r\n    retry,\r\n    getReport,\r\n    isRunning: state.status === 'running',\r\n    isComplete: state.status === 'completed',\r\n    isFailed: state.status === 'failed',\r\n    isStageComplete,\r\n    getStage,\r\n  };\r\n}\r\n\r\n// ============================================================================\r\n// useParallelBatch Hook - Parallel Processing Within Stages\r\n// ============================================================================\r\n\r\n/**\r\n * Result type for useParallelBatch\r\n */\r\nexport interface UseParallelBatchReturn<TItem, TOutput> {\r\n  /** Execute batch processing */\r\n  run: (items: TItem[]) => Promise<ParallelBatchResult<TOutput>>;\r\n  /** Current batch result */\r\n  result: ParallelBatchResult<TOutput> | null;\r\n  /** Loading state */\r\n  loading: boolean;\r\n  /** Current progress (0-100) */\r\n  progress: number;\r\n  /** Number of completed items */\r\n  completedCount: number;\r\n  /** Total items in current batch */\r\n  totalCount: number;\r\n  /** Cancel batch processing */\r\n  cancel: () => void;\r\n  /** Reset state */\r\n  reset: () => void;\r\n}\r\n\r\n/**\r\n * Hook for parallel batch processing\r\n *\r\n * Useful for processing multiple items in parallel within a pipeline stage.\r\n *\r\n * @example\r\n * ```tsx\r\n * // Basic usage with explicit types\r\n * function BatchProcessor() {\r\n *   const batch = useParallelBatch<string, ProcessedFile>('processFile', {\r\n *     concurrency: 4\r\n *   });\r\n *\r\n *   return (\r\n *     <div>\r\n *       <button\r\n *         onClick={() => batch.run(fileUrls)}\r\n *         disabled={batch.loading}\r\n *       >\r\n *         Process {fileUrls.length} Files\r\n *       </button>\r\n *\r\n *       {batch.loading && (\r\n *         <div>\r\n *           Processing: {batch.completedCount}/{batch.totalCount}\r\n *           ({batch.progress.toFixed(0)}%)\r\n *         </div>\r\n *       )}\r\n *\r\n *       {batch.result && (\r\n *         <div>\r\n *           Success: {batch.result.successful.length}\r\n *           Failed: {batch.result.failed.length}\r\n *         </div>\r\n *       )}\r\n *     </div>\r\n *   );\r\n * }\r\n *\r\n * // With typed registry - types are inferred!\r\n * // const batch = useParallelBatch('processFile');\r\n * ```\r\n */\r\nexport function useParallelBatch<\r\n  TName extends RegisteredFunctionName,\r\n  TItem = FunctionInput<TName extends string ? TName : never>,\r\n  TOutput = FunctionOutput<TName extends string ? TName : never>,\r\n>(\r\n  functionName: TName,\r\n  options: {\r\n    concurrency?: number;\r\n    computeOptions?: ComputeOptions;\r\n  } = {}\r\n): UseParallelBatchReturn<\r\n  TName extends keyof ComputeFunctionRegistry\r\n    ? ComputeFunctionRegistry[TName]['input']\r\n    : TItem,\r\n  TName extends keyof ComputeFunctionRegistry\r\n    ? ComputeFunctionRegistry[TName]['output']\r\n    : TOutput\r\n> {\r\n  type ActualItem = TName extends keyof ComputeFunctionRegistry\r\n    ? ComputeFunctionRegistry[TName]['input']\r\n    : TItem;\r\n  type ActualOutput = TName extends keyof ComputeFunctionRegistry\r\n    ? ComputeFunctionRegistry[TName]['output']\r\n    : TOutput;\r\n\r\n  const kit = useComputeKit();\r\n  const abortControllerRef = useRef<AbortController | null>(null);\r\n\r\n  const [state, setState] = useState<{\r\n    result: ParallelBatchResult<ActualOutput> | null;\r\n    loading: boolean;\r\n    progress: number;\r\n    completedCount: number;\r\n    totalCount: number;\r\n  }>({\r\n    result: null,\r\n    loading: false,\r\n    progress: 0,\r\n    completedCount: 0,\r\n    totalCount: 0,\r\n  });\r\n\r\n  const run = useCallback(\r\n    async (items: ActualItem[]): Promise<ParallelBatchResult<ActualOutput>> => {\r\n      // Cancel any existing batch\r\n      if (abortControllerRef.current) {\r\n        abortControllerRef.current.abort();\r\n      }\r\n\r\n      const abortController = new AbortController();\r\n      abortControllerRef.current = abortController;\r\n\r\n      setState({\r\n        result: null,\r\n        loading: true,\r\n        progress: 0,\r\n        completedCount: 0,\r\n        totalCount: items.length,\r\n      });\r\n\r\n      const startTime = performance.now();\r\n      const results: BatchItemResult<ActualOutput>[] = [];\r\n      const concurrency = options.concurrency ?? items.length;\r\n\r\n      // Process in batches based on concurrency\r\n      for (let i = 0; i < items.length; i += concurrency) {\r\n        if (abortController.signal.aborted) {\r\n          break;\r\n        }\r\n\r\n        const batch = items.slice(i, i + concurrency);\r\n        const batchPromises = batch.map(async (item, batchIndex) => {\r\n          const index = i + batchIndex;\r\n          const itemStart = performance.now();\r\n\r\n          try {\r\n            const data = (await kit.run(functionName, item, {\r\n              ...options.computeOptions,\r\n              signal: abortController.signal,\r\n            })) as ActualOutput;\r\n\r\n            const itemResult: BatchItemResult<ActualOutput> = {\r\n              index,\r\n              success: true,\r\n              data,\r\n              duration: performance.now() - itemStart,\r\n            };\r\n\r\n            return itemResult;\r\n          } catch (err) {\r\n            const itemResult: BatchItemResult<ActualOutput> = {\r\n              index,\r\n              success: false,\r\n              error: err instanceof Error ? err : new Error(String(err)),\r\n              duration: performance.now() - itemStart,\r\n            };\r\n\r\n            return itemResult;\r\n          }\r\n        });\r\n\r\n        const batchResults = await Promise.all(batchPromises);\r\n        results.push(...batchResults);\r\n\r\n        // Update progress\r\n        const completed = results.length;\r\n        setState((prev) => ({\r\n          ...prev,\r\n          completedCount: completed,\r\n          progress: (completed / items.length) * 100,\r\n        }));\r\n      }\r\n\r\n      const totalDuration = performance.now() - startTime;\r\n      const successful = results\r\n        .filter((r) => r.success && r.data !== undefined)\r\n        .map((r) => r.data as ActualOutput);\r\n      const failed = results\r\n        .filter((r) => !r.success)\r\n        .map((r) => ({ index: r.index, error: r.error! }));\r\n\r\n      const finalResult: ParallelBatchResult<ActualOutput> = {\r\n        results,\r\n        successful,\r\n        failed,\r\n        totalDuration,\r\n        successRate: successful.length / items.length,\r\n      };\r\n\r\n      setState({\r\n        result: finalResult,\r\n        loading: false,\r\n        progress: 100,\r\n        completedCount: items.length,\r\n        totalCount: items.length,\r\n      });\r\n\r\n      return finalResult;\r\n    },\r\n    [kit, functionName, options.concurrency, options.computeOptions]\r\n  );\r\n\r\n  const cancel = useCallback(() => {\r\n    if (abortControllerRef.current) {\r\n      abortControllerRef.current.abort();\r\n      abortControllerRef.current = null;\r\n    }\r\n    setState((prev) => ({\r\n      ...prev,\r\n      loading: false,\r\n    }));\r\n  }, []);\r\n\r\n  const reset = useCallback(() => {\r\n    cancel();\r\n    setState({\r\n      result: null,\r\n      loading: false,\r\n      progress: 0,\r\n      completedCount: 0,\r\n      totalCount: 0,\r\n    });\r\n  }, [cancel]);\r\n\r\n  // Cleanup on unmount\r\n  useEffect(() => {\r\n    return () => {\r\n      cancel();\r\n    };\r\n  }, [cancel]);\r\n\r\n  return {\r\n    ...state,\r\n    run,\r\n    cancel,\r\n    reset,\r\n  } as UseParallelBatchReturn<ActualItem, ActualOutput>;\r\n}\r\n\r\n// ============================================================================\r\n// Exports\r\n// ============================================================================\r\n\r\nexport type {\r\n  ComputeKitOptions,\r\n  ComputeOptions,\r\n  ComputeProgress,\r\n  PoolStats,\r\n  // Typed registry exports\r\n  ComputeFunctionRegistry,\r\n  RegisteredFunctionName,\r\n  FunctionInput,\r\n  FunctionOutput,\r\n  ComputeFn,\r\n  InferComputeFn,\r\n  DefineFunction,\r\n  HasRegisteredFunctions,\r\n} from '@computekit/core';\r\n\r\nexport { ComputeKit } from '@computekit/core';\r\n\r\n// Pipeline types are exported from interface declarations above\r\n"]}