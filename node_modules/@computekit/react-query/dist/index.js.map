{"version":3,"sources":["../src/index.tsx"],"names":[],"mappings":"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","file":"index.js","sourcesContent":["/**\r\n * ComputeKit React Query Integration\r\n * Lightweight TanStack Query bindings for ComputeKit\r\n */\r\n\r\nimport { useMemo, createContext, useContext, type ReactNode } from 'react';\r\nimport {\r\n  useQuery,\r\n  useMutation,\r\n  type UseQueryOptions,\r\n  type UseMutationOptions,\r\n  type QueryKey,\r\n} from '@tanstack/react-query';\r\nimport {\r\n  ComputeKit,\r\n  type ComputeKitOptions,\r\n  type ComputeOptions,\r\n  type ComputeFunctionRegistry,\r\n  type RegisteredFunctionName,\r\n  type FunctionInput,\r\n  type FunctionOutput,\r\n} from '@computekit/core';\r\n\r\n// ============================================================================\r\n// Context\r\n// ============================================================================\r\n\r\nconst ComputeKitContext = createContext<ComputeKit | null>(null);\r\n\r\nexport interface ComputeKitProviderProps {\r\n  /** ComputeKit options */\r\n  options?: ComputeKitOptions;\r\n  /** Custom ComputeKit instance (if you want to share with @computekit/react) */\r\n  instance?: ComputeKit;\r\n  /** Children */\r\n  children: ReactNode;\r\n}\r\n\r\n/**\r\n * Provider component for ComputeKit with React Query\r\n *\r\n * @example\r\n * ```tsx\r\n * import { QueryClient, QueryClientProvider } from '@tanstack/react-query';\r\n * import { ComputeKitProvider } from '@computekit/react-query';\r\n *\r\n * const queryClient = new QueryClient();\r\n *\r\n * function App() {\r\n *   return (\r\n *     <QueryClientProvider client={queryClient}>\r\n *       <ComputeKitProvider options={{ maxWorkers: 4 }}>\r\n *         <MyApp />\r\n *       </ComputeKitProvider>\r\n *     </QueryClientProvider>\r\n *   );\r\n * }\r\n * ```\r\n */\r\nexport function ComputeKitProvider({\r\n  options,\r\n  instance,\r\n  children,\r\n}: ComputeKitProviderProps): React.ReactElement {\r\n  const kit = useMemo(() => {\r\n    return instance ?? new ComputeKit(options);\r\n  }, [instance, options]);\r\n\r\n  return <ComputeKitContext.Provider value={kit}>{children}</ComputeKitContext.Provider>;\r\n}\r\n\r\n/**\r\n * Get the ComputeKit instance from context\r\n */\r\nexport function useComputeKit(): ComputeKit {\r\n  const kit = useContext(ComputeKitContext);\r\n  if (!kit) {\r\n    throw new Error('useComputeKit must be used within a ComputeKitProvider');\r\n  }\r\n  return kit;\r\n}\r\n\r\n// ============================================================================\r\n// Query Hook\r\n// ============================================================================\r\n\r\nexport interface UseComputeQueryOptions<TOutput> extends Omit<\r\n  UseQueryOptions<TOutput, Error, TOutput, QueryKey>,\r\n  'queryKey' | 'queryFn'\r\n> {\r\n  /** ComputeKit run options */\r\n  computeOptions?: ComputeOptions;\r\n}\r\n\r\n/**\r\n * Execute a registered compute function with React Query\r\n *\r\n * This hook integrates ComputeKit with TanStack Query, giving you:\r\n * - Automatic caching\r\n * - Background refetching\r\n * - Stale-while-revalidate\r\n * - Retry logic\r\n * - DevTools support\r\n *\r\n * @example\r\n * ```tsx\r\n * // Basic usage with explicit types\r\n * const { data, isLoading } = useComputeQuery<number, number>('fibonacci', 50);\r\n *\r\n * // With typed registry - types are inferred!\r\n * // declare module '@computekit/core' {\r\n * //   interface ComputeFunctionRegistry {\r\n * //     fibonacci: { input: number; output: number };\r\n * //   }\r\n * // }\r\n * // const { data } = useComputeQuery('fibonacci', 50); // data is number\r\n * ```\r\n */\r\nexport function useComputeQuery<\r\n  TName extends RegisteredFunctionName,\r\n  TInput = FunctionInput<TName extends string ? TName : never>,\r\n  TOutput = FunctionOutput<TName extends string ? TName : never>,\r\n>(\r\n  /** Name of the registered compute function */\r\n  name: TName,\r\n  /** Input to pass to the function */\r\n  input: TName extends keyof ComputeFunctionRegistry\r\n    ? ComputeFunctionRegistry[TName]['input']\r\n    : TInput,\r\n  /** React Query and ComputeKit options */\r\n  options?: UseComputeQueryOptions<\r\n    TName extends keyof ComputeFunctionRegistry\r\n      ? ComputeFunctionRegistry[TName]['output']\r\n      : TOutput\r\n  >\r\n) {\r\n  type ActualOutput = TName extends keyof ComputeFunctionRegistry\r\n    ? ComputeFunctionRegistry[TName]['output']\r\n    : TOutput;\r\n\r\n  const kit = useComputeKit();\r\n  const { computeOptions, ...queryOptions } = options ?? {};\r\n\r\n  return useQuery<ActualOutput, Error>({\r\n    queryKey: ['compute', name, input] as const,\r\n    queryFn: async () => {\r\n      const result = await kit.run(name, input, computeOptions);\r\n      return result as ActualOutput;\r\n    },\r\n    ...queryOptions,\r\n  });\r\n}\r\n\r\n// ============================================================================\r\n// Mutation Hook\r\n// ============================================================================\r\n\r\nexport interface UseComputeMutationOptions<TInput, TOutput> extends Omit<\r\n  UseMutationOptions<TOutput, Error, TInput>,\r\n  'mutationFn'\r\n> {\r\n  /** ComputeKit run options */\r\n  computeOptions?: ComputeOptions;\r\n}\r\n\r\n/**\r\n * Execute a registered compute function as a mutation\r\n *\r\n * Use this when you want to trigger computation manually (e.g., on button click)\r\n * rather than automatically on mount/input change.\r\n *\r\n * @example\r\n * ```tsx\r\n * // Basic usage with explicit types\r\n * const { mutate, isPending } = useComputeMutation<ImageData, ImageData>('blur');\r\n *\r\n * // With typed registry - types are inferred!\r\n * // const { mutate } = useComputeMutation('blur');\r\n * // mutate(imageData); // input type enforced\r\n * ```\r\n */\r\nexport function useComputeMutation<\r\n  TName extends RegisteredFunctionName,\r\n  TInput = FunctionInput<TName extends string ? TName : never>,\r\n  TOutput = FunctionOutput<TName extends string ? TName : never>,\r\n>(\r\n  /** Name of the registered compute function */\r\n  name: TName,\r\n  /** React Query and ComputeKit options */\r\n  options?: UseComputeMutationOptions<\r\n    TName extends keyof ComputeFunctionRegistry\r\n      ? ComputeFunctionRegistry[TName]['input']\r\n      : TInput,\r\n    TName extends keyof ComputeFunctionRegistry\r\n      ? ComputeFunctionRegistry[TName]['output']\r\n      : TOutput\r\n  >\r\n) {\r\n  type ActualInput = TName extends keyof ComputeFunctionRegistry\r\n    ? ComputeFunctionRegistry[TName]['input']\r\n    : TInput;\r\n  type ActualOutput = TName extends keyof ComputeFunctionRegistry\r\n    ? ComputeFunctionRegistry[TName]['output']\r\n    : TOutput;\r\n\r\n  const kit = useComputeKit();\r\n  const { computeOptions, ...mutationOptions } = options ?? {};\r\n\r\n  return useMutation<ActualOutput, Error, ActualInput>({\r\n    mutationFn: async (input: ActualInput) => {\r\n      const result = await kit.run(name, input as never, computeOptions);\r\n      return result as ActualOutput;\r\n    },\r\n    ...mutationOptions,\r\n  });\r\n}\r\n\r\n// ============================================================================\r\n// Factory for standalone usage (without context)\r\n// ============================================================================\r\n\r\n/**\r\n * Create compute query/mutation hooks bound to a specific ComputeKit instance\r\n *\r\n * Use this if you don't want to use the context provider, or need multiple\r\n * ComputeKit instances.\r\n *\r\n * @example\r\n * ```tsx\r\n * import { ComputeKit } from '@computekit/core';\r\n * import { createComputeHooks } from '@computekit/react-query';\r\n *\r\n * const kit = new ComputeKit();\r\n * kit.register('fibonacci', (n: number) => { ... });\r\n *\r\n * const { useQuery, useMutation } = createComputeHooks(kit);\r\n *\r\n * // With typed registry - types are inferred!\r\n * const { data } = useQuery('fibonacci', 50); // data is number\r\n * ```\r\n */\r\nexport function createComputeHooks(kit: ComputeKit) {\r\n  return {\r\n    /**\r\n     * Query hook bound to this ComputeKit instance\r\n     */\r\n    useQuery: <\r\n      TName extends RegisteredFunctionName,\r\n      TInput = FunctionInput<TName extends string ? TName : never>,\r\n      TOutput = FunctionOutput<TName extends string ? TName : never>,\r\n    >(\r\n      name: TName,\r\n      input: TName extends keyof ComputeFunctionRegistry\r\n        ? ComputeFunctionRegistry[TName]['input']\r\n        : TInput,\r\n      options?: Omit<\r\n        UseComputeQueryOptions<\r\n          TName extends keyof ComputeFunctionRegistry\r\n            ? ComputeFunctionRegistry[TName]['output']\r\n            : TOutput\r\n        >,\r\n        'computeOptions'\r\n      > & {\r\n        computeOptions?: ComputeOptions;\r\n      }\r\n    ) => {\r\n      type ActualOutput = TName extends keyof ComputeFunctionRegistry\r\n        ? ComputeFunctionRegistry[TName]['output']\r\n        : TOutput;\r\n\r\n      const { computeOptions, ...queryOptions } = options ?? {};\r\n\r\n      return useQuery<ActualOutput, Error>({\r\n        queryKey: ['compute', name, input] as const,\r\n        queryFn: async () => {\r\n          const result = await kit.run(name, input, computeOptions);\r\n          return result as ActualOutput;\r\n        },\r\n        ...queryOptions,\r\n      });\r\n    },\r\n\r\n    /**\r\n     * Mutation hook bound to this ComputeKit instance\r\n     */\r\n    useMutation: <\r\n      TName extends RegisteredFunctionName,\r\n      TInput = FunctionInput<TName extends string ? TName : never>,\r\n      TOutput = FunctionOutput<TName extends string ? TName : never>,\r\n    >(\r\n      name: TName,\r\n      options?: Omit<\r\n        UseComputeMutationOptions<\r\n          TName extends keyof ComputeFunctionRegistry\r\n            ? ComputeFunctionRegistry[TName]['input']\r\n            : TInput,\r\n          TName extends keyof ComputeFunctionRegistry\r\n            ? ComputeFunctionRegistry[TName]['output']\r\n            : TOutput\r\n        >,\r\n        'computeOptions'\r\n      > & {\r\n        computeOptions?: ComputeOptions;\r\n      }\r\n    ) => {\r\n      type ActualInput = TName extends keyof ComputeFunctionRegistry\r\n        ? ComputeFunctionRegistry[TName]['input']\r\n        : TInput;\r\n      type ActualOutput = TName extends keyof ComputeFunctionRegistry\r\n        ? ComputeFunctionRegistry[TName]['output']\r\n        : TOutput;\r\n\r\n      const { computeOptions, ...mutationOptions } = options ?? {};\r\n\r\n      return useMutation<ActualOutput, Error, ActualInput>({\r\n        mutationFn: async (input: ActualInput) => {\r\n          const result = await kit.run(name, input as never, computeOptions);\r\n          return result as ActualOutput;\r\n        },\r\n        ...mutationOptions,\r\n      });\r\n    },\r\n\r\n    /** The ComputeKit instance */\r\n    kit,\r\n  };\r\n}\r\n\r\n// ============================================================================\r\n// Exports\r\n// ============================================================================\r\n\r\nexport type {\r\n  ComputeKitOptions,\r\n  ComputeOptions,\r\n  // Typed registry exports\r\n  ComputeFunctionRegistry,\r\n  RegisteredFunctionName,\r\n  FunctionInput,\r\n  FunctionOutput,\r\n} from '@computekit/core';\r\nexport { ComputeKit } from '@computekit/core';\r\n"]}